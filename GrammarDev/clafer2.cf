entrypoints Module ;


-- To regenerate grammar:
--         cd src/Front
--         bnfc -m -haskell clafer.cf
--         Modify files Absclafer.hs, ErrM.hs, Printclafer.hs, so that they consider Front as a module name. (can be done by running make from src).
--         happy -gca Parclafer.y
--         alex -g Lexclafer.x

comment "//" ;
comment "/*" "*/" ;

Module.         Module ::= [Declaration] ;

EnumDecl.       Declaration ::= "enum" PosIdent "=" [EnumId] ;
ElementDecl.    Declaration ::= Element ;

Clafer.         Clafer ::= Abstract GCard PosIdent Super Card Init Elements ;
Constraint.     Constraint ::= "[" [ConstrExp] "]" ;
SoftConstraint. SoftConstraint ::= "(" [Exp] ")";
Goal.		Goal ::= "<<" [Exp] ">>" ;

-- The scope's parameters for all Temporal Patterns are basically an expression 
-- ScopeParam.         ScopeParam ::= Exp;
-- TmpScopeBefore.		TmpScope ::= "before" ScopeParam;

-- Scopes of Temporal Patterns - BEGIN
TmpScopeGlobally.	TmpScope ::= "globally" ;
TmpScopeGlobally.	TmpScope ::=  ;
TmpScopeBefore.		TmpScope ::= "before" Exp ;
TmpScopeAfter.		TmpScope ::= "after" Exp ;
TmpScopeBetweenAnd.	TmpScope ::= "between" Exp "and" Exp ;
TmpScopeAfterUntil.	TmpScope ::= "after" Exp "until" Exp ;

--Question: here maybe we can use something like this?
-- 	_.	TmpScope ::= ;   or 	coercions TmpScope 1;
-- instead of:	TmpScopeGlobally.	TmpScope ::= ;

-- Scopes of Temporal Patterns - END


-- List of Temporal Patterns - BEGIN
TmpPrecedes.	ConstrExp ::= Exp "precedes" Exp TmpScope;
TmpRespondsTo.	ConstrExp ::= Exp "respondsTo" Exp TmpScope;
TmpRespondsTo.	ConstrExp ::= Exp "responds" "to" Exp TmpScope;

TmpAbsence.	ConstrExp1 ::= Exp "is" "false" TmpScope ;
TmpExistence.	ConstrExp1 ::= Exp "is" "true" TmpScope ;
TmpBoundedExistence.	ConstrExp1 ::= Exp "is" "true" PosInteger "times" TmpScope ;

-- logical && has a higher precedence than logical ||
ConstrExpOr.	ConstrExp2	::= ConstrExp "||" ConstrExp ;
ConstrExpAnd.	ConstrExp3	::= ConstrExp "&&" ConstrExp ;

coercions ConstrExp 3 ;

-- what's the main difference between Existence and Universality?
-- Do we need both patterns?



-- Non pattern constraint
NonPatternsExp.		ConstrExp ::= Exp;


-- List of Temporal Patterns - END




-- Immutable constraint
ImmutableConstr.	ConstrExp ::= Immutable;

-- Question
-- Are the next rules written ok? They do what we need for the let / binding variable to state value scenario?


{-
-- version 1 for LET scenario
DeclLetBindingValue.	DeclLetBinding	::= PosIdent "=" Exp ;
DeclLetBindingSet.	DeclLetBinding	::= PosIdent ":" SetExp ;
DeclLet.		Exp		::= "let" [DeclLetBinding] "|" Exp ;
separator nonempty DeclLetBinding "" ;
-}

-- version 2 for Let scenario
{-
DeclLetBindingValue.	DeclLetBindingValue	::= PosIdent "=" Exp ;
DeclLetBindingSet.	DeclLetBindingSet	::= PosIdent ":" SetExp ;

DeclLetBindValue.	Exp16		::= "let" [DeclLetBindingValue] "|" Exp ;
separator nonempty DeclLetBindingValue "," ;

DeclLetBindSet.		Exp16		::= "let" [DeclLetBindingSet] "|" Exp ;
separator nonempty DeclLetBindingSet "," ;
-}
-- both versions of LET scenario work, but which one is better???


DeclLetBindingValue.	DeclLetBindingValue	::= PosIdent "=" Exp ;
DeclLetBindValue.	Exp16	::= "let" [DeclLetBindingValue] "|" Exp ;
separator nonempty DeclLetBindingValue "," ;

DeclBindingSet.		DeclBindingSet	::= PosIdent ":" SetExp ;
DeclBindSet1.		SetExp		::= "{" [DeclBindingSet] "|" Exp "}" ;
separator nonempty DeclBindingSet "," ;

DeclBindSet2.		SetExp		::= "{" [Decl] "|" Exp "}" ;
separator nonempty Decl "," ;



{-
DeclarationSet.		DeclarationSet ::= [PosIdent] ":" SetExp ;
DeclBindSet2.		SetExp		::= "{" [DeclarationSet] "|" Exp "}" ;
separator nonempty DeclarationSet "," ;
-}



AbstractEmpty.  Abstract ::= ;
Abstract.       Abstract ::= "abstract" ;

-- ElementsEmpty causes parsing problems
-- Why does this happen???
ElementsEmpty.  Elements ::= ;
ElementsList.   Elements ::= "{" [Element] "}" ;

Subclafer.      Element ::= Clafer ;
ClaferUse.      Element ::= "`" Name Card Elements ;
Subconstraint.  Element ::= Constraint ;
Subgoal.	Element ::= Goal; 
Subsoftconstraint. Element ::=SoftConstraint;

SuperEmpty.     Super ::=  ;
SuperSome.      Super ::= SuperHow SetExp ;

SuperColon.     SuperHow ::= ":" ;
SuperArrow.     SuperHow ::= "->" ;
SuperMArrow.    SuperHow ::= "->>" ;

InitEmpty.      Init ::= ;
InitSome.       Init ::= InitHow Exp ;

InitHow_1.      InitHow ::= "=" ;
InitHow_2.      InitHow ::= ":=" ;

GCardEmpty.     GCard ::= ;
GCardXor.       GCard ::= "xor" ;
GCardOr.        GCard ::= "or" ;
GCardMux.       GCard ::= "mux" ;
GCardOpt.       GCard ::= "opt" ;
GCardInterval.  GCard ::= NCard ;

CardEmpty.      Card ::= ;
CardLone.       Card ::= "?" ;
CardSome.       Card ::= "+" ;
CardAny.        Card ::= "*" ;
CardNum.        Card ::= PosInteger ;
CardInterval.   Card ::= NCard ;

NCard.          NCard  ::= PosInteger ".." ExInteger ;

ExIntegerAst.   ExInteger ::= "*" ;
ExIntegerNum.   ExInteger ::= PosInteger ;

Path.           Name ::= [ModId] ;

-- LTL precedence order: <AP>, !, X, G, F, W, U, R, &&, ||, => 

DeclAllDisj.    Exp   ::= "all" "disj" Decl "|" Exp ;
DeclAll.        Exp   ::= "all"        Decl "|" Exp ;
DeclQuantDisj.  Exp   ::= Quant "disj" Decl "|" Exp ;
DeclQuant.      Exp   ::= Quant        Decl "|" Exp ;
EGMax.          Exp1  ::= "max" Exp2 ;
EGMin.          Exp1  ::= "min" Exp2 ;
EIff.           Exp1  ::= Exp1 "<=>" Exp2 ;
EImplies.       Exp2  ::= Exp2 "=>"  Exp3 ;
EOr.            Exp3  ::= Exp3 "||"  Exp4 ;
EXor.           Exp4  ::= Exp4 "xor" Exp5 ;
EAnd.           Exp5  ::= Exp5 "&&"  Exp6 ;
LtlRel.         Exp6  ::= Exp6 "R"  Exp7 ;
LtlUntil.       Exp6  ::= Exp6 "U"  Exp7 ;
LtlWUntil.      Exp6  ::= Exp6 "W"  Exp7 ;
LtlF.           Exp7  ::= "F"  Exp8 ;
LtlG.           Exp7  ::= "G"  Exp8 ;
LtlX.           Exp8  ::= "X"  Exp9 ;
ENeg.           Exp9  ::= "!" Exp10 ;
ELt.            Exp10  ::= Exp10 "<"  Exp11 ;
EGt.            Exp10  ::= Exp10 ">"  Exp11 ;
EEq.            Exp10  ::= Exp10 "="  Exp11 ;
ELte.           Exp10  ::= Exp10 "<=" Exp11 ;
EGte.           Exp10  ::= Exp10 ">=" Exp11 ;
ENeq.           Exp10  ::= Exp10 "!=" Exp11 ;
EIn.            Exp10  ::= Exp10 "in" Exp11 ;
ENin.           Exp10  ::= Exp10 "not" "in" Exp11 ;
QuantExp.       Exp11  ::= Quant Exp15 ;
EAdd.           Exp12  ::= Exp12  "+" Exp13 ;
ESub.           Exp12  ::= Exp12  "-" Exp13 ;
EMul.           Exp13 ::= Exp13 "*" Exp14 ;
EDiv.           Exp13 ::= Exp13 "/" Exp14 ;
ESumSetExp.     Exp14 ::= "sum" Exp15;
ECSetExp.       Exp14 ::= "#" Exp15 ;
EMinExp.        Exp14 ::= "-" Exp15 ;
EImpliesElse.   Exp15 ::= "if" Exp15 "then" Exp15 "else" Exp16 ;
EInt.           Exp16 ::= PosInteger ;
EDouble.        Exp16 ::= PosDouble ;
EStr.           Exp16 ::= PosString ;
ESetExp.        Exp16 ::= SetExp ;

Union.          SetExp  ::= SetExp  "++" SetExp1 ;
UnionCom.       SetExp  ::= SetExp  ","  SetExp1 ;
Difference.     SetExp1 ::= SetExp1 "--" SetExp2 ;
Intersection.   SetExp2 ::= SetExp2 "&"  SetExp3 ;
Domain.         SetExp3 ::= SetExp3 "<:" SetExp4 ;
Range.          SetExp4 ::= SetExp4 ":>" SetExp5 ;
Join.           SetExp5 ::= SetExp5 "."  SetExp6 ;
ClaferId.       SetExp6 ::= Name ;

Decl.           Decl ::= [LocId] ":" SetExp ;

QuantNo.        Quant ::= "no" ;
QuantLone.      Quant ::= "lone" ;
QuantOne.       Quant ::= "one" ;
QuantSome.      Quant ::= "some" ;

EnumIdIdent.    EnumId ::= PosIdent ;
ModIdIdent.     ModId  ::= PosIdent ;
LocIdIdent.     LocId  ::= PosIdent ;

Pos . Pos ::= Integer Integer;
Span . Span ::= Pos Pos;

separator           Declaration ""  ;
separator  nonempty EnumId      "|" ;
separator           Element     ""  ;
separator           Exp         ""  ;
separator           ConstrExp         ""  ;
separator  nonempty LocId       ";" ;
separator  nonempty ModId       "\\" ;

coercions Exp 16 ;
coercions SetExp 6 ;

--QuantNo.        Quant ::=  No ;
--position token No ('n' 'o');



-- This is the same as the following rule?
--position token Immutable ('i' 'm' 'm' 'u' 't' 'a' 'b' 'l' 'e') ;

position token Immutable {"immutable"} ;

position token PosInteger (digit+) ;
position token PosDouble (digit+ '.' digit+ ('e' '-'? digit+)?) ;
position token PosString '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ;
position token PosIdent (letter (letter|digit|'_'|'\'')*) ;

